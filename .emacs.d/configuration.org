#+TITLE: Emacs Configuration
#+AUTHOR: Björn Lindström
#+EMAIL: bkhl@elektrubadur.se
#+STARTUP: overview

* Introduction

This is my Emacs configuration. Inspirations include:

- Harry R. Schwart's [[https://github.com/hrs/dotfiles/blob/main/emacs/dot-emacs.d/configuration.org][Emacs configuration]] and [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]].
- [[https://emacscast.org/][EmacsCast]].
- Protesilaos Stavrou's  [[https://protesilaos.com/codelog/][blog]] and [[https://www.youtube.com/channel/UC0uTPqBCFIpZxlz_Lv1tk_g][videos]].

* Set personal information

#+begin_src emacs-lisp
(setq user-full-name "Björn Lindström"
      user-mail-address "bkhl@elektrubadur.se"
      calendar-latitude 13.76
      calendar-longitude 100.54
      calendar-location-name "Bangkok")
#+end_src

* General helper functions

** Get secret from keyring

Use ~secret-tool~ to get a password or similar from the user keyring.

To store a secret, use a command like ~secret-tool store --label=Foo foo password~. It can then be used here using ~(bkhl/get-secret "foo" "password")~.

#+begin_src emacs-lisp
(defun bkhl/get-secret (attribute value)
  (shell-command-to-string
   (format "secret-tool lookup '%s' '%s'" attribute value)))
#+end_src

* Look and feel
** Load Modus Operandi theme

#+begin_src emacs-lisp
(use-package modus-themes
  :custom
  (modus-themes-syntax 'faint)
  (modus-themes-org-blocks 'greyscale)
  (modus-themes-scale-headings t)
  (modus-themes-links 'neutral-underline)
  (modus-themes-diffs 'desaturated)
  :config
  (load-theme 'modus-operandi t))
#+end_src

** Enable syntax highlighting everywhere

#+begin_src emacs-lisp
(global-font-lock-mode t)
#+end_src

** Fonts

Setting fonts. I primarily use the ~variable-pitch~ and ~fixed-pitch~ faces in ~org-mode~.

#+begin_src emacs-lisp
(set-face-attribute 'default nil
                    :family "Iosevka Custom"
                    :height 120)
(set-face-attribute 'variable-pitch nil
                    :family "Vollkorn")
(set-face-attribute 'fixed-pitch nil
                    :family "Iosevka Custom")
#+end_src

** Render some keywords as symbols

This primarily makes =lambda= get rendered as =λ= in Emacs Lisp, but can also be enabled in other modes.

#+begin_src emacs-lisp
(global-prettify-symbols-mode 1)
#+end_src

** Customize mode line

Hide minor modes from mode line with Minions.

#+begin_src emacs-lisp
(use-package minions
  :config
  (setq minions-mode-line-lighter ""
        minions-mode-line-delimiters '("" . ""))
  (minions-mode))
#+end_src

Enable smart-mode-line

#+begin_src emacs-lisp
(use-package smart-mode-line
  :config
  (sml/setup))
#+end_src

** Disable bell

Disable warning bell, both the default audio one and the visual one otherwise enabled by =sensible-defaults.el=.

#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src

** Show loading time on startup

#+begin_src emacs-lisp
(defun display-startup-echo-area-message ()
  (message "Emacs init time: %s" (emacs-init-time)))
#+end_src

** Set window title

Set window title including current buffer or filename, and a project from [[https://gitlab.com/bkhl/etui][Etui]] or [[https://gitlab.com/bkhl/toolboxes/-/blob/latest/scripts/toolbox-project][toolbox-project]].

Also use a straight or squiggly line to show if the buffer has modifications.

#+begin_src emacs-lisp
(setq frame-title-format
      '(
        "%b"
        (:eval (if (buffer-modified-p) " ⁓ " " — "))
        (:eval (or
                (getenv "ETUI_PROJECT")
                (getenv "TOOLBOX_PROJECT")
                (system-name)))))
#+end_src

** Highlight matching pairs of parentheses.

#+begin_src emacs-lisp
(show-paren-mode t)
(setq show-paren-delay 0.0)
#+end_src

** Make yes/no prompts shorter

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Prompt before closing Emacs

#+begin_src emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+end_src

** Make middle-clicking mouse yank at point

#+begin_src emacs-lisp
(setq mouse-yank-at-point t)
#+end_src

** Bind some keys to resize font size

#+begin_src emacs-lisp
(defun bkhl/reset-text-size ()
  (interactive)
  (text-scale-set 0))

(define-key global-map (kbd "C-)") 'bkhl/reset-text-size)
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C-=") 'text-scale-increase)
(define-key global-map (kbd "C-_") 'text-scale-decrease)
(define-key global-map (kbd "C--") 'text-scale-decrease)
#+end_src

* Configure ~emacsclient~ bevaviour

Raise new ~emacsclient~ frames when created

#+begin_src emacs-lisp
  (defun bkhl/focus-frame ()
    (select-frame-set-input-focus (selected-frame)))
  (add-hook 'server-switch-hook 'bkhl/focus-frame)
  (add-hook 'server-after-make-frame-hook 'bkhl/focus-frame)
#+end_src

* Key bindings and navigation
** Start with an empty scratch buffer.

#+begin_src emacs-lisp
(setq inhibit-startup-screen t
      initial-scratch-message nil)
#+end_src

** Start opening files from home directory

Unless overridden by a buffer, when prompting to open a file, start in the home directory.

#+begin_src emacs-lisp
(setq default-directory "~/")
#+end_src

** Load Hydra key binding library

#+begin_src emacs-lisp
(use-package hydra)
#+end_src

** Disable =C-z=

Disabling =C-z=, which normally minimizes the window, which is rather distracting.

#+begin_src emacs-lisp
(unbind-key "C-z")
#+end_src

** Bind Home/End to move to start/end of line

#+begin_src emacs-lisp
(global-set-key (kbd "<home>") 'move-beginning-of-line)
(global-set-key (kbd "<end>") 'move-end-of-line)
#+end_src

** Managing windows

Use  =M-o= to enable a Hydra for moving between or manipulating windows.

#+begin_src emacs-lisp
(defhydra bkhl/hydra-other-window ()
  "Window"

  ("M-o" other-window)

  ("<left>" windmove-left)
  ("b" windmove-left)

  ("<right>" windmove-right)
  ("f" windmove-right)

  ("<up>" windmove-up)
  ("p" windmove-up)

  ("<down>" windmove-down)
  ("n" windmove-down)

  ("k" delete-window :color blue)
  ("0" delete-window :color blue)

  ("1" delete-other-window :color blue)

  ("h" split-window-below :color blue)
  ("2" split-window-below :color blue)

  ("v" split-window-right :color blue)
  ("3" split-window-right :color blue))

(bind-key "M-o" #'bkhl/hydra-other-window/body)
#+end_src

** Selectrum for incremental narrowing commands

[[https://github.com/raxod502/selectrum][Selectrum]] is a library for incremental narrowing, and [[https://github.com/raxod502/prescient.el][Prescient]] adds more intelligent sorting of results to it.

#+begin_src emacs-lisp
(use-package selectrum
  :config (selectrum-mode))

(use-package selectrum-prescient
  :config
  (selectrum-prescient-mode)
  (prescient-persist-mode))
#+end_src

** CTRLF for search within buffer

This packages replaces the standard ~isearch-forward~ with a search function based on Selectrum.

Using an advice to use an "unbranded" prompt.

#+begin_src emacs-lisp
(defun bkhl/ctrlf-prompt (prompt)
  (if (string-prefix-p "CTRLF " prompt)
      (concat "Search " (substring prompt 6))
    prompt))

(use-package ctrlf
  :config
  (advice-add 'ctrlf--prompt :filter-return #'bkhl/ctrlf-prompt)
  (ctrlf-mode))
#+end_src

** Use =C-S-f= to expand region

This package allows first selecting the word the current pointer is on, and then by repeating the key press grow the selection to the next larger structure.

#+begin_src emacs-lisp
(use-package expand-region
  :bind ("C-S-w" . er/expand-region))
#+end_src

* File handling
** Store backups in tmp directory

Store backups and autosaves in ~temporary-file-directory~. This risks losing some data on a system crash, but I am not very concerned about that as generally my important files are in some kind of version control.

#+begin_src emacs-lisp
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

** Automatically sync updated files

If a file changes, automatically refresh buffers containing the file, so that it doesn't get out of sync.

#+begin_src emacs-lisp
(global-auto-revert-mode t)
#+end_src

** Trim trailing spaces and enforce final newline

When files are saved, delete trailing whitespace and ensure that the file ends with a newline.

#+begin_src emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(setq require-final-newline t)
#+end_src

** Offer to create parent directories on save

When saving a file to a directory that doesn't exist, offer to create it.

#+begin_src emacs-lisp
  (defun bkhl/ask-create-directory ()
    (when buffer-file-name
      (let ((dir (file-name-directory buffer-file-name)))
        (when (and (not (file-exists-p dir))
                   (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
          (make-directory dir t)))))
  (add-hook 'before-save-hook 'bkhl/ask-create-directory)
#+end_src

* General text editing
** Highlight selected region and apply changes to it

Highlight the region when the mark is active.

#+begin_src emacs-lisp
(transient-mark-mode t)
#+end_src

Set it so that if a selection is active, typed text will replace the selection.

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

** Disable indentation using tabs.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

** Set default line length to 80

#+begin_src emacs-lisp
(setq-default fill-column 80)
#+end_src

** Set default indentation width to 4.

#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src

** Show character name in character description

When using =C-x == to look up the character under the point, also show Unicode
character name.

#+begin_src emacs-lisp
(setq what-cursor-show-names t)
#+end_src

** Automatically pair matching characters like parenthesis

Enable ~electric-pair-mode~, which enables automatic insert of matching characters for example for parentheses.

#+begin_src emacs-lisp
(electric-pair-mode 1)
#+end_src

** Enable ~yasnippet~

#+begin_src emacs-lisp
(use-package yasnippet)
#+end_src

** Operate on the current line if no region is active

This module allows a number of functions to operate on the current line if no region is selected.

#+begin_src emacs-lisp
(use-package whole-line-or-region
  :config (whole-line-or-region-global-mode))
#+end_src

* Project management and version control
** Projectile project management

Load the Projectile project management package.

#+begin_src emacs-lisp
(use-package projectile
  :config
  (projectile-mode 1)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+end_src

This allows setting a value in a =.dir-locals.el= to make Projectile list only
files that are tracked in the Git repository.

#+begin_src emacs-lisp
(add-to-list 'safe-local-variable-values
             '(projectile-git-command . "git ls-files -zc --exclude-standard"))
#+end_src

** Magit Git integration

Load ~magit~, for working with Git.

#+begin_src emacs-lisp
(use-package magit
  :bind
  ("C-x g" . magit-status)

  :commands
  magit-call-git

  :custom
  (magit-push-always-verify nil)
  (git-commit-summary-max-length 50))
#+end_src

** Automatic commit on save

Function to do automatic commit on save in certain repos. This is for use with for example ~org-mode~, to enable finding things after accidental changes.

#+begin_src emacs-lisp
(defun bkhl/magic-commit-current-buffer()
  (magit-call-git "add" buffer-file-name)
  (magit-call-git "commit"
                  "-m"
                  (format "Automatic commit on save of %s"
                          buffer-file-name))
  (magit-refresh))
#+end_src

To use this as an ~after-save-hook~ in a project, create a ~.dir-locals.el~ with something like this:

#+begin_example
((org-mode . ((eval . (add-hook
                       'after-save-hook
                       #'bkhl/magic-commit-current-buffer
                       nil t)))))
#+end_example

** Show uncommited changes in fringe

Load ~diff-hl~ which shows uncommited changes in the left-hand fringe.

#+begin_src emacs-lisp
(use-package diff-hl
  :config
  (global-diff-hl-mode 1)
  (diff-hl-flydiff-mode 1)
  (add-hook 'magit-pre-refresh-hook
            'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook
            'diff-hl-magit-post-refresh))
#+end_src

** ~git-timemachine~ for browsing file history

#+begin_src emacs-lisp
(use-package git-timemachine
  :after magit
  :hook magit)
#+end_src

** Make ~vc-diff~ imitate the diff format of Magit

#+begin_src emacs-lisp
(setq diff-font-lock-prettify t)
#+end_src

** Ally remembering risky local variables

This overrides the Emacs settings that enforces having to accept local variables matching certain patterns every time they are used.

#+begin_src emacs-lisp
(advice-add 'risky-local-variable-p :override #'ignore)
#+end_src

* Programming
** In programming modes, treat words in camel case symbols as separate.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'subword-mode)
#+end_src

** Add keybinding to comment/uncomment line or region

#+begin_src emacs-lisp
(defun bkhl/comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if
there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
        (setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)))


(global-set-key (kbd "M-;")
                'bkhl/comment-or-uncomment-region-or-line)
#+end_src

** Automatically scroll to new output in the =*compilation*= buffer.

#+begin_src emacs-lisp
(setq compilation-scroll-output t)
#+end_src

** Multi-purpose programming packages
*** Check code on the fly with Flycheck

Enable ~flycheck-mode~ globally.

#+begin_src emacs-lisp
(use-package flycheck
  :straight (flycheck :type git
                      :host github
                      :repo "bkhl/flycheck")
  :init (global-flycheck-mode))
#+end_src

Plugin to show Flycheck errors in a tool tip.

#+begin_src emacs-lisp
(use-package flycheck-pos-tip
  :hook (flycheck-mode . flycheck-pos-tip-mode))
#+end_src

*** Language Server Protocol with ~lsp-mode~

Load ~lsp-mode~ itself.

#+begin_src emacs-lisp
(use-package lsp-mode
  :init (setq lsp-keymap-prefix "C-c l")
  :after flycheck
  :custom (lsp-modeline-code-action-fallback-icon "‡"))
#+end_src


#+begin_src emacs-lisp
(use-package lsp-ui
  :after lsp-mode)
#+end_src

*** Completion with ~company~

#+begin_src emacs-lisp
(use-package company
  :config
  (add-hook 'after-init-hook 'global-company-mode)
  (bind-key "M-/" 'company-complete-common))
#+end_src

Use the ~company-posframe~ plugin to show the ~company~ menus in a separate frame, not affected by e.g. variable pitch mode.

#+begin_src emacs-lisp
(use-package company-posframe
  :custom (company-posframe-show-indicator nil)
  :hook (company-mode . company-posframe-mode))
#+end_src

Use [[https://github.com/raxod502/prescient.el][Prescient]] to sort alternatives in Company.

#+begin_src emacs-lisp
(use-package company-prescient
  :config (company-prescient-mode))
#+end_src

** Programming languages
*** Docker

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode ("\\'Dockerfile\\.?" . dockerfile-mode))
#+end_src
*** Emacs Lisp

Fix indentation of quoted lists. Copied from [[https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/][this Reddit post]].

#+begin_src emacs-lisp
(advice-add #'calculate-lisp-indent :override #'bkhl/calculate-lisp-indent)

(defun bkhl/calculate-lisp-indent (&optional parse-start)
  "Add better indentation for quoted and backquoted lists."
  ;; This line because `calculate-lisp-indent-last-sexp` was defined with `defvar`
  ;; with it's value ommited, marking it special and only defining it locally. So
  ;; if you don't have this, you'll get a void variable error.
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp parse-start) (integerp parse-start))
             (goto-char parse-start))
            ((null parse-start) (beginning-of-defun))
            (t (setq state parse-start)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      ;; Containing sexp has nothing before this line
                      ;; except the first element. Indent under that element.
                      (= (point) calculate-lisp-indent-last-sexp)

                      ;; First sexp after `containing-sexp' is a keyword. This
                      ;; condition is more debatable. It's so that I can have
                      ;; unquoted plists in macros. It assumes that you won't
                      ;; make a function whose name is a keyword.
                      ;; (when-let (char-after (char-after (1+ containing-sexp)))
                      ;;   (char-equal char-after ?:))

                      ;; Check for quotes or backquotes around.
                      (let* ((positions (elt state 9))
                             (last (car (last positions)))
                             (rest (reverse (butlast positions)))
                             (any-quoted-p nil)
                             (point nil))
                        (or
                         (when-let (char (char-before last))
                           (or (char-equal char ?')
                               (char-equal char ?`)))
                         (progn
                           (while (and rest (not any-quoted-p))
                             (setq point (pop rest))
                             (setq any-quoted-p
                                   (or
                                    (when-let (char (char-before point))
                                      (or (char-equal char ?')
                                          (char-equal char ?`)))
                                    (save-excursion
                                      (goto-char (1+ point))
                                      (looking-at-p
                                       "\\(?:back\\)?quote[\t\n\f\s]+(")))))
                           any-quoted-p))))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))
#+end_src

*** Python

Use Python 3 as default Python interpreter. This is for environments that does not have a ~python~ command, or that points it to Python 2.

#+begin_src emacs-lisp
(setq python-shell-interpreter "python3"
      python-shell-interpreter-args "-i")
#+end_src

Package for activating Python virtual environments.

#+begin_src emacs-lisp
(use-package pyvenv)
#+end_src

Elpy, package with IDE-like features for Python. I've found so far that this is faster and more reliable than ~lsp-mode~ for Python.

#+begin_src emacs-lisp
(use-package elpy
  :defer t
  :custom (elpy-rpc-python-command "python3")
  :init (advice-add 'python-mode :before 'elpy-enable))
#+end_src

Helper function to set ~flycheck~ executables to match the current virtual environment.

#+begin_src emacs-lisp
(defun bkhl/flycheck-python-set-executables ()
  "Use some commands from virtual environments in flycheck."
  (let ((exec-path (python-shell-calculate-exec-path)))
    (setq-local flycheck-python-pylint-executable
                (executable-find "pylint"))))

(defun bkhl/flycheck-python-set-executables-add-hook ()
  (add-hook 'flycheck-before-syntax-check-hook
            #'bkhl/flycheck-python-set-executables 'local))

(add-hook 'python-mode-hook
          'bkhl/flycheck-python-set-executables-add-hook)
#+end_src

Add formatters for Python.

 #+begin_src emacs-lisp
 (use-package reformatter
   :config
   (reformatter-define python-black-format
                       :program "black" :args '("-q" "-"))

   (reformatter-define python-isort-format
                       :program "isort" :args '("-q" "-"))

   (defun bkhl/python-format-buffer ()
     (python-isort-format-buffer)
     (python-black-format-buffer))

   (with-eval-after-load 'python
     (bind-key "C-c f" (lambda ()
                         (interactive)
                         (python-isort-format-buffer)
                         (python-black-format-buffer))
               python-mode-map)))
#+end_src

*** Rust

Use ~rustic~ for Rust editing.

#+begin_src emacs-lisp
(use-package rustic
  :after (lsp-mode company)
  :custom
  (rustic-format-trigger 'on-save))
#+end_src

* Writing
** Use single space to delimit sentences

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

** Prose writing environment with Olivetti

A minor mode that automatically adjusts margins &c. for prose writing.

#+begin_src emacs-lisp
  (use-package olivetti
    :config
    (add-hook 'org-mode-hook 'olivetti-mode))
#+end_src

* ~org-mode~ planning and note-taking

As an exception to the rule in this file, ~org-mode~ is not called with ~use-package~, because it has so much configuration that it warrants splitting it into sections, and it has implicitly been loaded before running this file, given that this configuration itself is written in ~org-mode~.

** =TODO= keywords

Customizing =TODO= keywords adding my own state =READ=, which is for things to
read and possibly make notes on or file.

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence
         "TODO(t)" "READ(r)"
         "|"
         "DONE(d)" "CANCELLED(c)")))
#+end_src

** Directories

Set a custom variable for the notes directory, so that it can be referred to
later.

#+begin_src emacs-lisp
(setq bkhl/org-directory "~/Documents/Notes/")
#+end_src

** Make initial scratch buffer use ~org-mode~

#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode)
#+end_src

** Editing

Edit src blocks in current window.

#+begin_src emacs-lisp
(setq org-src-window-setup 'current-window)
#+end_src

Make indentation and fonts in code blocks work according to mode for the language in the block.

#+begin_src emacs-lisp
(setq org-src-tab-acts-natively t
      org-src-fontify-natively t)
#+end_src

Disable the extra indentation in src blocks.

#+begin_src emacs-lisp
(setq org-edit-src-content-indentation 0)
#+end_src

This prevents accidental editing in invisible regions.

#+begin_src emacs-lisp
(setq org-catch-invisible-edits 'error)
#+end_src

Shortcut for inserting a block of Elisp.

#+begin_src emacs-lisp
(add-to-list 'org-structure-template-alist
             '("el" . "src emacs-lisp"))
#+end_src

** Display

Enable ~org-indent~ mode, which makes org-mode indent sections visually, but not in the saved files.

#+begin_src emacs-lisp
(setq org-startup-indented t)
#+end_src

Use variable fonts in ~org-mode~ buffers.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'variable-pitch-mode)
#+end_src

Display bullets instead of asterisks.

#+begin_src emacs-lisp
(use-package org-superstar
  :init
  (add-hook 'org-mode-hook 'org-superstar-mode))
#+end_src

Hide the characters surrounding emphasized phrases

#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
#+end_src

Use real ellipsis character for collapsed subtrees, and prefix it with a space.

#+begin_src emacs-lisp
(setq org-ellipsis " …")
#+end_src

** Capturing

Add templates for use by ~org-capture~

#+begin_src emacs-lisp
(setq org-capture-templates
      `(("i" "inbox" entry (file ,(concat bkhl/org-directory "Inbox.org"))
         "* TODO %?")))
#+end_src

Bind =C-c c= to ~org-capture~ to quickly add notes.

#+begin_src emacs-lisp
(bind-key "C-c c" 'org-capture)
#+end_src

** Refiling

This allows refiling within the current buffer, or any agenda files.

#+begin_src emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 9)
                           (org-agenda-files :maxlevel . 9))
      org-outline-path-complete-in-steps nil
      org-refile-use-outline-path 'file)
#+end_src

** Agendas

Install ~org-super-agenda~ for improved agenda interface, and categorize tasks roughly by urgency.

I use recurring tasks for habits rather than the habit feature, because [[http://www.orgzly.com/][Orgzly]] currently only supports the former feature, so that's why I use a tag for those here.

#+begin_src emacs-lisp
(use-package org-super-agenda
  :custom (org-super-agenda-groups
           '((:name "Schedule"
              :time-grid t)
             (:name "Due today"
              :deadline today)
             (:name "Overdue"
              :deadline past)
             (:name "Due soon"
              :deadline future)
             (:name "Habits"
              :tag ("habit"))
             (:name "Other"
              :todo ("TODO" "READ"))))
  :config (org-super-agenda-mode))
#+end_src

Search all files in the notes directory when creating agendas.

#+begin_src emacs-lisp
(setq org-agenda-files `(,bkhl/org-directory))
#+end_src

Keybinding to open an agenda view.

#+begin_src emacs-lisp
(bind-key "C-c a" 'org-agenda)
#+end_src

Hide done tasks from the agenda.

#+begin_src emacs-lisp
(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t)
#+end_src
* File formats
** hledger

#+begin_src emacs-lisp
(use-package ledger-mode
  :mode "\\.journal\\'"
  :custom
  (ledger-post-auto-align nil)
  :config
  (setq ledger-mode-should-check-version nil
        ledger-report-links-in-register nil
        ledger-binary-path "hledger"
        ledger-default-date-format ledger-iso-date-format))
#+end_src

** YAML

#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

* Other modes
** dired

Make file sizes shown in dired human readable.

#+begin_src emacs-lisp
(setq-default dired-listing-switches "-alh")
#+end_src

* Internet Relay Chat

Set up the Circe IRC client.

#+begin_src emacs-lisp
(defun bkhl/circe-get-password (host)
  (bkhl/get-secret host "password"))

(use-package circe
  :custom
  (tracking-position 'end)
  (circe-network-defaults nil)
  (circe-reduce-lurker-spam t)
  (circe-network-options
   '(("Freenode"
      :host "irc.elektrubadur.se"
      :port 50080
      :tls t
      :user "bkhl/Freenode"
      :pass bkhl/circe-get-password)))
  :config
  (circe-lagmon-mode)
  (enable-circe-color-nicks)
  (enable-lui-track))

(defun bkhl/irc ()
  (interactive)
  (circe "Freenode"))

(defalias 'irc 'bkhl/irc)
#+end_src
